from opto import trace
from opto.trainer.sampler import Sampler
from opto.trainer.loader import DataLoader
from opto.trainer.guide import AutoGuide
from opto.trainer.algorithms.priority_search.utils import is_node_copy


class Guide(AutoGuide):

    def get_feedback(self, query, response, reference=None, **kwargs):
        """
        Provide feedback based on the query and response.

        Args:
            query: The query to analyze.
            response: The response generated by the model.
            reference: Optional reference answer for comparison.
            **kwargs: Additional context or parameters.

        Returns:
            A tuple containing a score and feedback string.
        """
        score = response == reference
        feedback = "Exact match!" if score == 1.0 else "Not an exact match."
        return score, feedback

@trace.model
class Agent:

    def __init__(self):
        self.param = trace.node(1., trainable=True)
        self.state = 0

    @trace.bundle()
    def forward(self, x):
        self.state += 1
        return self.state


def test_sample_with_single_agent():

    xs = [1, 2, 3, 4, 5]
    infos = [1, 2, 3, 4, 5]
    batch_size = 3
    sub_batch_size = 2
    num_threads = 2
    dataset = {'inputs': xs, 'infos': infos}
    loader = DataLoader(dataset, batch_size=batch_size, randomize=False)
    sampler = Sampler(loader=loader, guide=Guide(), sub_batch_size=sub_batch_size, num_threads=num_threads)


    ## Test with a single agent
    samples, batch = sampler.sample([Agent()])

    # check batch is equal to dataset's first batch_size elements
    assert batch['inputs'] == dataset['inputs'][:3]
    assert batch['infos'] == dataset['infos'][:3]

    assert len(samples) == 2

    # a batch of 3 is split into 2 sub-batches of size 2 and 1
    assert is_node_copy(samples[0].module.parameters()[0], samples[1].module.parameters()[0])
    assert len(samples[0].rollouts) == 2
    assert len(samples[1].rollouts) == 1

    for rollouts in samples:
        for rollout in rollouts:
            assert rollout.target == 1  # state is not affected by multiple calls
            rollout.target.backward('Fake feedback')
            # each rollout should be independent so `has been backwarded.` error should not be raised


    samples, batch = sampler.sample([Agent()])

    # check batch is equal to dataset's second batch_size elements
    assert batch['inputs'] == dataset['inputs'][3:]
    assert batch['infos'] == dataset['infos'][3:]
    assert len(samples) == 1
    assert len(samples[0].rollouts) == 2

    for rollouts in samples:
        for rollout in rollouts:
            assert rollout.target == 1  # state is not affected by multiple calls
            rollout.target.backward('Fake feedback')
            # each rollout should be independent so `has been backwarded.` error should not be raised

def test_sample_with_multiple_agents():
    """
    Test sampling with multiple agents.
    This will create a batch of samples from two agents.
    """

    xs = [1, 2, 3, 4, 5]
    infos = [1, 2, 3, 4, 5]
    batch_size = 3
    sub_batch_size = 2
    num_threads = 2
    dataset = {'inputs': xs, 'infos': infos}
    loader = DataLoader(dataset, batch_size=batch_size, randomize=False)
    sampler = Sampler(loader=loader, guide=Guide(), sub_batch_size=sub_batch_size, num_threads=num_threads)


    ## Test with multiple agents
    samples, batch = sampler.sample([Agent(), Agent()])

    # check batch is equal to dataset's first batch_size elements
    assert batch['inputs'] == dataset['inputs'][:3]
    assert batch['infos'] == dataset['infos'][:3]

    assert len(samples) == 4, f"Expected 4 samples, got {len(samples)}"

    assert is_node_copy(samples[0].module.parameters()[0], samples[1].module.parameters()[0])
    assert len(samples[0].rollouts) == 2
    assert len(samples[1].rollouts) == 1

    assert is_node_copy(samples[2].module.parameters()[0], samples[3].module.parameters()[0])
    assert len(samples[2].rollouts) == 2
    assert len(samples[3].rollouts) == 1

    for rollouts in samples:
        for rollout in rollouts:
            rollout.target.backward('Fake feedback')
            # each rollout should be independent so `has been backwarded.` error should not be raised

    samples, batch = sampler.sample([Agent(), Agent()])
    # check batch is equal to dataset's second batch_size elements
    assert batch['inputs'] == dataset['inputs'][3:]
    assert batch['infos'] == dataset['infos'][3:]

    assert len(samples) == 2, f"Expected 2 samples, got {len(samples)}"

    assert len(samples[0].rollouts) == 2
    assert len(samples[1].rollouts) == 2

    for rollouts in samples:
        for rollout in rollouts:
            rollout.target.backward('Fake feedback')
            # each rollout should be independent so `has been backwarded.` error should not be raised