import numpy as np
import copy
from dataclasses import dataclass
from typing import Union, List, Tuple, Dict, Any, Optional
from opto import trace
from opto.trainer.utils import batch_run
from opto.trainer.guide import AutoGuide

@dataclass
class Rollout:
    """ A rollout is a single sample from the environment. It contains the module, input, info, target, score, and feedback.
        This is used to store the results of the agent's evaluation on a single input.
    """
    module: trace.Module  # the trace.Module (proposal)
    x: Any  # the input data
    info: Any  # additional information about the input
    target: trace.Node  # the target output (if applicable)
    score: float  # the score of the proposal
    feedback: Any  # the feedback from the guide

    def to_dict(self):
        """ Convert the rollout to a dictionary representation. """
        return {
            "module": self.module,
            "x": self.x,
            "info": self.info,
            "target": self.target.data,
            "score": self.score,
            "feedback": self.feedback,
        }


class RolloutsGraph:
    """ A rollouts graph is a collection of rollouts generated by the same agent (trace.Module) on different inputs.
    """
    module: trace.Module  # the trace.Module (proposal) that generated the rollouts
    rollouts: List[Rollout]  # a list of Rollout objects generated by the module on different inputs
    def __init__(self, rollouts):
        """ Initialize a rollouts graph with the given rollouts. """
        # Check that all rollouts have the same module
        if not all(rollouts[0].module == r.module for r in rollouts):
            raise ValueError("All rollouts must have the same module.")
        self.module = rollouts[0].module  # the module is the same for all rollouts
        self.rollouts = rollouts

    def get_scores(self):
        """ Get the scores of the rollouts in the subgraph. """
        return [r.score for r in self.rollouts]

    def __len__(self):
        """ Get the number of rollouts in the subgraph. """
        return len(self.rollouts)

    def __iter__(self):
        """ Iterate over the rollouts in the subgraph. """
        return iter(self.rollouts)

    def extend(self, other):
        """ Extend the subgraph with another subgraph. """
        if not isinstance(other, RolloutsGraph):
            raise ValueError("Can only extend with another RolloutsGraph.")
        if self.module != other.module:
            raise ValueError("Cannot extend with a subgraph with a different module.")
        self.rollouts.extend(other.rollouts)

    def to_list(self):
        """ Convert the subgraph to a list of rollouts. """
        return [r.to_dict() for r in self.rollouts]


@dataclass
class RolloutConfig:
    module: trace.Module  # the trace.Module (proposal)
    xs: List[Any]  # the input data
    infos: List[Any]  # additional information about the input
    guide: Any  # the guide to evaluate the proposals

    def __init__(self,
                    module: trace.Module,
                    xs: List[Any],
                    infos: List[Any],
                    guide: Any):
        """ Initialize a rollout config with the given module, inputs, infos, and guide. """
        # check types
        if not isinstance(module, trace.Module):
            raise TypeError("module must be a trace.Module.")
        if not isinstance(xs, list):
            raise TypeError("xs must be a list.")
        if not isinstance(infos, list):
            raise TypeError("infos must be a list.")
        if not isinstance(guide, AutoGuide):
            raise TypeError("guide must be a AutoGuide.")
        if len(xs) != len(infos):
            raise ValueError("Length of xs must match length of infos.")
        self.module = module
        self.xs = xs
        self.infos = infos
        self.guide = guide


# TODO move it and refactor the trainer code
def standard_forward(agent, x, guide, info, min_score=0):
    """ Forward and compute feedback.

        Args:
            agent: trace.Module
            x: input
            guide: (question, student_answer, info) -> score, feedback
            info: additional information for the guide
            min_score: minimum score when exception happens

        Returns:
            target: output of the agent
            score: score from the guide
            feedback: feedback from the guide
        """
    try:
        target = agent(x)
        score, feedback = guide(x, target.data, info)
    except trace.ExecutionError as e:
        target = e.exception_node
        score, feedback = min_score, target.create_feedback('full')
    return target, score, feedback


def sample_rollouts(configs, num_threads=1, forward=None, min_score=None, description="Sampling rollouts.") -> List[RolloutsGraph]:
    """ Sample a batch of data based on the proposed parameters. All proposals are evaluated on the same batch of inputs.

    Args:
        configs (List[RolloutConfig]): A list of RolloutConfig objects, each containing\
            - module: the trace.Module (proposal) to evaluate
            - xs: a list of input data to evaluate the proposal on
            - infos: a list of additional information about the inputs
            - guide: the guide to evaluate the proposals
        num_threads (int): Number of threads to use for sampling.
        forward (callable, optional): A custom forward function to use instead of the default one
            (standard_forward). If None, the default forward function is used.
        min_score (float, optional): Minimum score to return when an exception occurs. If None, it defaults to 0.
        description (str): Description to display in the progress bar.
    Returns:
        List[RolloutsGraph]: A list of RolloutsGraph objects, one for each config
    """
    if forward is None:
        forward = standard_forward

    # Forward the agent on the inputs and compute the feedback using the guide
    batched_forward = batch_run(max_workers=num_threads, description=description)(forward)

    agents = [ config.module for config in configs for _ in range(len(config.xs)) ]  # repeat each agent for each input
    xs = [ x for config in configs for x in config.xs ]  # flatten
    infos = [ info for config in configs for info in config.infos ]  # flatten
    guides = [ config.guide for config in configs for _ in range(len(config.xs)) ]  # repeat each guide for each input

    outputs = batched_forward(agent=agents,
                              x=xs,
                              info=infos,
                              guide=guides,  # guide will be broadcasted inside
                              min_score=min_score)

    # Collect the results into a list of RolloutsGraph objects
    results = []  # list of subgraphs (RolloutsGraph objects) for each agent
    _index = 0  # to track the indices processed
    for i in range(len(configs)):
        rollouts = []
        _agent = configs[i].module  # the first agent in the batch
        for j in range(len(configs[i].xs)):
            assert _agent == agents[_index], "Agent mismatch in the rollouts."
            rollout = Rollout(
                module=agents[_index],
                x=xs[_index],
                info=infos[_index],
                target=outputs[_index][0],  # target output
                score=outputs[_index][1],  # score of the proposal
                feedback=outputs[_index][2],  # feedback of the proposal
            )
            _index += 1  # increment the index
            rollouts.append(rollout)
        results.append(RolloutsGraph(rollouts))  # append the subgraph to the results
    return results



class Sampler:

    """ A sampler that samples a batch of data from the loader and evaluates the agents on the sampled inputs.
    """
    def __init__(self, loader, guide, num_threads=1, sub_batch_size=None, forward=None, score_range=(-np.inf, np.inf)):
        """ Initialize the sampler with a data loader and a guide.

        Args:
            loader (DataLoader): The data loader to sample from.
            guide (AutoGuide): The guide to evaluate the proposals.
            num_threads (int): Number of threads to use for sampling.
            sub_batch_size (int, optional): Size of the sub-batch to use for sampling. If None, uses the batch size.
            score_range (tuple): The range of scores to consider valid.
        """
        self.loader = loader
        self.guide = guide
        self.num_threads = num_threads
        if sub_batch_size is None:
            sub_batch_size = loader.batch_size
        else:
            assert sub_batch_size <= loader.batch_size, "sub_batch_size must be less than or equal to the loader's batch size."
        self.sub_batch_size = sub_batch_size
        self.score_range = score_range
        if forward is None:
            self.forward = standard_forward

    @property
    def dataset(self):
        """ Get the dataset of the loader. """
        return self.loader.dataset

    @dataset.setter
    def dataset(self, value):
        """ Set the dataset of the loader. """
        assert isinstance(value, dict), "Dataset must be a dictionary with 'inputs' and 'infos' keys."
        assert 'inputs' in value and 'infos' in value, "Dataset must contain 'inputs' and 'infos' keys."
        assert len(value['inputs']) == len(value['infos']), "Length of inputs must match length of infos."
        self.loader.dataset = value

    @property
    def batch_size(self):
        """ Get the batch size of the loader. """
        return self.loader.batch_size

    @batch_size.setter
    def batch_size(self, value):
        """ Set the batch size of the loader. """
        self.loader.batch_size = value

    @property
    def n_epochs(self):
        """ Get the number of epochs of the loader. """
        return self.loader.n_epochs

    def sample(self, agents, description_prefix=''):
        """ Sample a batch of data from the loader and evaluate the agents.

        Args:
            agents (list): A list of trace.Modules (proposed parameters) to evaluate.

        Returns:
           batch (dict):
                A dictionary containing the sampled inputs and infos, where:
                - 'inputs': a list of inputs sampled from the loader
                - 'infos': a list of additional information for each input

            samples (list of RolloutsGraph):
                A list of RolloutsGraph objects, each containing the rollouts generated by the agents on the sampled inputs.
                Each RolloutsGraph contains:
                - 'module': the trace.Module (proposal)
                - 'rollouts': a list of Rollout objects containing:
                    - 'x': the input data
                    - 'info': additional information about the input
                    - 'target': the target output (if applicable)
                    - 'score': the score of the proposal
                    - 'feedback': the feedback from the guide

        NOTE: The return might not be ordered in the same way as the agents.
        """

        assert all(isinstance(a, trace.Module) for a in agents), "All agents must be trace.Modules."

        # Get a batch of inputs and infos from the loader
        xs, infos = self.loader.sample()
        batch = {
            'inputs': xs,
            'infos': infos
        }

        # Evaluate each agent on the sampled inputs
        #
        # agents : a1, a2
        # inputs: x1, x2, x3
        # infos: i1, i2, i3
        # sub_batch_size: 2
        #
        # The forward is called in this order:
        # (a1, x1, i1, guide1),
        # (a1, x2, i2, guide1),
        # (deepcopy(a1), x3, i3, guide1)
        # (a2, x1, i1, guide2),
        # (a2, x2, i2, guide2),
        # (deepcopy(a2), x3, i3, guide2)

        # Create rollout configs for each agent
        batch_size = len(xs)
        assert len(infos) == batch_size, "Length of infos must match length of xs."
        configs = []
        for agent in agents:
            _xs, _infos = [], []
            for i in range(batch_size):
                if i % self.sub_batch_size == 0 and i > 0:
                    configs.append(RolloutConfig(module=agent, xs=_xs, infos=_infos, guide=self.guide))
                    # reset
                    agent = copy.deepcopy(agent) # create a deep copy of the agent for the next sub-batch
                    _xs, _infos = [], []
                _xs.append(xs[i])
                _infos.append(infos[i])
            if _xs:  # if there are inputs in the sub-batch
                configs.append(RolloutConfig(module=agent, xs=_xs, infos=_infos, guide=self.guide))

        # Sample rollouts using the configs
        description = description_prefix + f"Sampling {len(agents)} agents on {batch_size} inputs"
        samples = sample_rollouts(configs,
                        forward=self.forward,
                        num_threads=self.num_threads,
                        min_score=self.score_range[0],
                        description=description)

        assert len(samples) == len(agents)*(batch_size // self.sub_batch_size + (1 if batch_size % self.sub_batch_size > 0 else 0)), f"Expected {len(agents)*(batch_size // self.sub_batch_size + (1 if batch_size % self.sub_batch_size > 0 else 0))} samples, got {len(samples)}"

        return samples, batch
